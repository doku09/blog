# ✏️ 학습내용

## 파일입출력과 성능최적화 - 하나씩쓰기

### 자바 파일입출력으로 10MB 파일 만들기 
```java
public class CreateFileV1 {
    public static void main(String[] args) throws IOException {
        FileOutputStream fos = new FileOutputStream(FILE_NAME);
        long startTime = System.currentTimeMillis();
    
        for (int i = 0; i < FILE_SIZE; i++) {
            fos.write(1);
        }
        fos.close();
        long endTime = System.currentTimeMillis();
    
        System.out.println("File created: " + FILE_NAME);
        System.out.println("File size: " + FILE_SIZE/1024/1024 + "MB") ;
        System.out.println("Time taken: " + (endTime - startTime) + "ms") ;
    }
}
```

이렇게 반복문으로 write()를 실행하는것은  무거운 작업을 1000만번 반복하는것과 마찬가지다 마치 화물차에 물건을 하나씩넣고 1000만번을 왔다갔다 하는것이라고 생각하면 된다. 이렇게 자바에서 운영체제로 시스템콜을 반복적으로 하면 운영체제나 하드웨어 레벨에서 여러가지 최적화가 발생한다. 

이런 문제를 해결하기 위해 버퍼를 사용한다.

## 파일 입출력과 성능 최적화2 - 버퍼활용
### 버퍼 사용하여 파일 쓰기
```java
public class BufferedConst {
    public static final String FILE_NAME = "temp/buffered.dat";
    public static final int FILE_SIZE = 10 * 1024 * 1024; // 10MB
    public static final int BUFFER_SIZE = 8192; // 8KB
}

public class CreateFileV2 {
    public static void main(String[] args) throws IOException {
        FileOutputStream fos = new FileOutputStream(FILE_NAME);
        long startTime = System.currentTimeMillis();
    
        byte[] buffer = new byte[BUFFER_SIZE];
        int bufferIndex = 0;
    
        for (int i = 0; i < FILE_SIZE; i++) {
            buffer[bufferIndex++] = 1;
    
            if(bufferIndex == BUFFER_SIZE) {
                fos.write(buffer);
                bufferIndex = 0;
            }
        }
    
        // 버퍼가 아직 남아있으면 버퍼에 남은 부분을 쓴다
        if(bufferIndex > 0) {
            fos.write(buffer, 0, bufferIndex);
        }
    
        long endTime = System.currentTimeMillis();
    
        System.out.println("File created: " + FILE_NAME);
        System.out.println("File size: " + FILE_SIZE/1024/1024 + "MB") ;
        System.out.println("Time taken: " + (endTime - startTime) + "ms") ;
    }
```
버퍼의 크기가 커진다고 비례적으로 속도가 줄어들지는 않는다. 디스크나 파일 시스템에서 데이터를 읽고 쓰는 기본단위가 보통 4,8kb이기 때문이다.


### 버퍼 사용하여 파일 읽기
```java
public class ReadFileV2 {
    public static void main(String[] args) throws IOException {
        FileInputStream fis = new FileInputStream(BufferedConst.FILE_NAME);
        long startTime = System.currentTimeMillis();
    
        byte[] buffer = new byte[BUFFER_SIZE];
        int fileSize = 0;
        int size;
        while((size = fis.read(buffer)) != -1) {
            fileSize += size;
        }
        fis.close();
    
        long endTime = System.currentTimeMillis();
        System.out.println("File created: " + FILE_NAME);
        System.out.println("File size: " + fileSize/1024/1024 + "MB") ;
        System.out.println("Time taken: " + (endTime - startTime) + "ms") ;
    }
}
```

## 파일 입출력과 성능 최적화3 - Buffered스트림 쓰기
직접 버퍼를 구현해서 쓰려고 하니, 남은 버퍼도 수동으로 채워주어야 하고, 코드가 복잡해졌다. 이를 해결하기 위해 나온게 Buffered 스트림이다
```java
public class CreateFileV3 {
    public static void main(String[] args) throws IOException {
        FileOutputStream fos = new FileOutputStream(FILE_NAME);
        BufferedOutputStream bos = new BufferedOutputStream(fos, BUFFER_SIZE);// 버퍼가 차면 fileoutputstream에 보내준다.
    
        long startTime = System.currentTimeMillis();
    
        for (int i = 0; i < FILE_SIZE; i++) {
            bos.write(1);
        }
        bos.close();
        long endTime = System.currentTimeMillis();
    
        System.out.println("File created: " + FILE_NAME);
        System.out.println("File size: " + FILE_SIZE/1024/1024 + "MB") ;
        System.out.println("Time taken: " + (endTime - startTime) + "ms") ;
    }
}
```
`BufferedOutputStream`은 내부에서 단순히 버퍼 기능만 제공한다. 따라서 반드시 대상 OutputStream이 있어야한다. 여기서는 FileOutputStream 객체를 생성자에 전달한다. 버퍼가 지정한 크기대로 가득 차면 outputstream에 전달한다. 이후 outputstream이 write를 호출하면 시스템콜로 OS에 전달한다.
+ close()를 호출하면 close()가 연쇄적으로 호출된다. 따라서 마지막에 연결한 `BufferedOutputStream`만 닫아주면 `FileOutpuStream`도 닫힌다.
+ 꼭 마지막에 연결한 스트림을 닫아주어야한다.

### 기본 스트림, 보조 스트림
+ `FileOutputStream`과 같이 단독으로 사용할 수 있는 스트림을 **기본 스트림**이라고 한다.
+ `BufferedOutputStream`과 같이 단독으로 사용할 수 없고, 보조 기능을 제공하는 스트림을 **보조 스트림**이라고한다.



# #️⃣ 생각해볼 문제
# 💫 학습자료