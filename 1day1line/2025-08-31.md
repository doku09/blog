# ✏️ 학습내용
## 네트워크 프로그램3 
여러 클라이언트가 하나의 서버소켓에 접속할때 어떻게 해야하는지 알아본다. 
- 클라이언트가 서버에 접속하면 서버 소켓의 accept() 메서드가 Socket을 반환한다.
- 하나의 클라이언트 당 하나의 스레드를 생성하여 소켓으로 통신한다. 

> 자바 객체는 GC가 되지만 자바 외부 자원은 자동으로 GC가 되지앟는다. 따라서 꼭 정리를 해주어야한다.


## 자원정리1
### 핵심 예외가 바뀌는 문제 
```java
private static void logic() throws CallException, CloseException {

    ResourceV1 resource1 = null;
    ResourceV1 resource2 = null;

    try {
        resource1 = new ResourceV1("resource1");
        resource2 = new ResourceV1("resource2");

        resource1.call();
        resource2.callEx(); // call 예외발생
    } catch(CallException e) {
        System.out.println("ex: " + e);
        throw e;
    } finally {
        if(resource2 != null) {
            resource2.closeEx(); // 자원정리하다가 예외발생
        }
        if( resource1 != null) {
            resource1.closeEx();
        }
    }
}
```
위에서 call()을 실행하다가 예외가발생하고, finally에서도 자원을 정리하다가 예외가발생한다면 예외는 최종적으로 CloseException만 던지게 된다. 
만약 CallException에 대한 대응이 있었는데 CloseException 예외만 던져지게 되어 처리된다면 심각한 문제가 발생한다. 이럴때는 close의 예외도 `try catch` 로 잡아주어야한다. 

```java
finally {
			if(resource2 != null) {
				try {
					resource2.closeEx();
				} catch (CloseException e){
					// close()에서 발생한 예외는 버린다. 필요하면 로깅 정도
					System.out.println("close ex: " + e);
				}

			}
			if( resource1 != null) {
				try {
					resource1.closeEx();
				} catch (CloseException e){
					System.out.println("close ex: " + e);
				}
			}
		}
```
핵심적인 문제들은 해결되었지만 코드 부분에서 아쉬운 부분이 많다.
- resource를 생성과동시에 사용하지 못한다.(try catch와 코드블록이 다르기때문에)
- 개발자가 close()를 실행하지 않을 수 있다. 
- 자원정리 순서를 자원 생성순서와 반대로 하지 않을 가능성이 있다. 

try-with-resource는 위의 문제를 해결하기 위해 여러기능을 제공한다. 
- 스코프 범위가 한정된다. (선언과 동시에사용할 수 있음)
- 선언한 자원은 close()를 자동으로 실행한다.
- 자원을 생성한 순서 반대로 정리해준다. 
- close()시 발생한 예외는 부가예외로 취급하고 핵심예외 밑으로 넣어 핵심예외가 던져지게 한다.

### 
# #️⃣ 생각해볼 문제
# 💫 학습자료