## 🔄 락에는 두 가지 방식이 있다
### 1. ✅ 낙관적 락 (Optimistic Lock)
"설마 충돌 나겠어? 그냥 해보고, 진짜 충돌 났을 때만 처리하자!"

@Version 필드를 써서,
업데이트할 때 누가 먼저 수정했는지 체크함

충돌 나면 예외 터짐, 그럼 retry 하거나 실패 처리하면 된다.

🧠 예시

포인트가 잘 안 겹치는 경우 (사용자가 많고 동시 요청은 드뭄)

성능에 민감하고, 충돌은 레어하게 일어나는 상황

### 2. 🛑 비관적 락 (Pessimistic Lock)
"어차피 충돌 날 거 같은데? 그럼 아예 다른 사람 못 건들게 막자!"

select for update로 조회하면서 락을 건다.

다른 요청은 락 풀릴 때까지 기다린다.

🧠 예시

쿠폰 선착순, 한정된 재고 등

정확성 우선, 충돌 자주 일어남


# 🔧 자바 락 vs DB 락 차이

항목|	자바 락 (ReentrantLock, ConcurrentMap 등)	|DB 락 (@Version, select for update)
--|--|--
영역|	JVM 내부 (한 인스턴스 안에서만 유효)	|데이터베이스 레벨 (여러 인스턴스/요청 포함)
적용 대상	|메모리 객체	|DB의 Row or Table
멀티 서버 대응|	❌ 불가능 (인스턴스 밖에서는 무효)	|✅ 가능
적합한 상황	|단일 서버, 캐시, 임시 작업|	공유 데이터(포인트, 재고 등) 변경 시

### 🤔 왜 자바 락만으로는 부족할까?
예를 들어:
서버가 2대 있음 (A, B)

같은 사용자가 서버 A와 서버 B에 동시에 요청 보냄 (포인트 차감)

만약 ReentrantLock을 사용하면?
서버 A에서 락을 걸었어도,

서버 B는 그걸 모르기 때문에 동시에 처리 가능 → 데이터 꼬임!

#### 🧠 즉, 자바 락은 이런 경우에만 유용해:
한 JVM 안에서만 동시성 제어할 때 (ex. 캐시, 메모리 풀)

또는 테스트 환경, 단일 서버일 때

#### 🎯 그래서 어떻게 쓰면 좋을까?
+ DB 업데이트가 있는 도메인 → DB Lock으로 동시성 제어 (JPA 버전 필드 or for update)
+ 메모리 구조 보호 or 캐시 → 자바 락 (ReentrantLock, synchronized, ConcurrentMap 등)

✨ 한 줄 요약
+ "자바 락은 JVM 안에서만, DB 락은 진짜 데이터를 보호하기 위해 꼭 필요!"