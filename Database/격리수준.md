# 트랜잭션 격리 수준
- 트랜잭션 격리수준이랑 여러 트랜잭션이 처리 될때, 트랜잭션끼리 얼마나 서로 고립되어 있는지를 나타낸다. 
- 즉, 특정 트랜잭션이 다른 트랜잭션에 변경한 데이터를 볼 수 있도록 허용할지 말지를 결정함. 

격리수준은 아래 4개로 나눈다.
- READ UNCOMMITTED
    - 어떤 트랜잭션의 변경 내용이 commit이나 rollback 상관없이 다른 트랜잭션에 보인다. 
    > Dirty Read라고도 불림
    > 1. A트랜잭션에서 10번 사원의 나이를 27살->28살로 변경
    > 2. 아직 커밋되지 않음
    > 3. 28살이 조회됨

- READ COMMITTED (Oracle)
    - 어떤 트랜잭션의 변경이 커밋되어야만 다른 트랜잭션에서 조회가능, 온라인서비스에서 가장 많이 선택되는 격리수준이다. 
    > B트랜잭션에서 10번 사원의 나이를 조회해도 27살이 된다. (undo 영역에 저장. MVCC 참조)
    - 언뜻 정합성 문제가 해결된것처럼 보이지만, `NON_REPEATABLE READ` 부정합 문제가 발생할수 있다.
  
- REPEATABLE READ (mysql)
    - 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있는 격리수준이다.
    > 1. 1번 트랜잭션이 1번 사원조회
    > 2. 2번 트랜잭션이 1번사원의 이름을 변경하고 커밋
    > 3. 1번 트랜잭션에서 1번 사원을 다시조회
    > 4. undo 영역에 백업된 데이터 반환? 

자신의 트랜잭션 번호보다 낮은 트랜잭션 번호에서 커밋된 내용만 보게한다. 
    > 1번 트랜잭션은 2번보다 낮으므로 2번에서 변경된 내용은 추적하지 않아서 2번이 변경한 내용을 보여주지 않는다.
- SERIALIZABLE
아래로 내려갈수록 트랜잭션간 고립정도가 높아지고 성능이 떨어지는것이 일반적이다.

**materialized view pattern**
-crud를 커맨드 와 쿼리할때 관리를 따로하고싶다할때 사용 
- 검색에 활용되는 DB를 바꾼다. 쓰기와 읽기 DB를 분리 
- 쓰기 후 DB까지 이어지는 과정 
- 조회에 맞춰서 정리한다. 인기상품?? 
- 스케쥴러를 통해서 materialized view를 업데이트 한다. 
- 권장하지는 않는다. 적재를 
- 쿼리로 데이터를 반환하는걸 제안
- 쿼리로 성능이 얼마나 나올까 
- 인기상품!!
