# Chap1. TDD & 클린아키텍처
1. 주어진 기능에 대해 테스트 케이스를 작성하고, 모든 주요 시나리오를 커버할 수 있는가?
2. 강결합을 지양하고, 테스트가 용이하도록 코드를 구조화할 수 있는가?
3. 적절한 상황에서 Mock이나 Stub을 객체 상호작용에 따라서 분리해 의존성 관리를 할 수 있는가?
4. 기능 개발 전에 실패하는 테스트를 작성하고, 이를 기반으로 코드를 구현 및 리팩토링할 수 있는가?
5. 단위 테스트, 통합 테스트, E2E 테스트 중 상황에 맞는 테스트 전략을 선택하고 적용할 수 있는가?
6. 레이어드, 헥사고날, 클린 아키텍처 패턴의 특징과 차이를 설명하고 상황에 맞게 적용할 수 있는가?
7. 비즈니스 로직, 데이터 처리, 프레젠테이션 계층을 명확히 분리하고 각 계층의 역할을 구분하여 코드를 작성할 수 있는가?
8. 의존성 역전을 통해 상위 모듈이 하위 모듈에 의존하지 않도록 설계하고, 기능 확장 시 기존 코드를 수정하지 않고도 추가할 수 있는가?
9. 중복을 최소화하고, 추상화를 적절히 사용하며, 가독성 높은 코드를 작성할 수 있는가?
10. 각 계층에 대해 단위 테스트, 통합 테스트, E2E 테스트를 작성하고, 아키텍처 설계가 요구사항을 충족하는지 검증할 수 있는가?

# Chap2. 서버 구축
1. API 명세를 작성하고, Mock API를 구현할 수 있는가?
2. 비즈니스 로직에 대한 단위 테스트를 작성하고 실행할 수 있는가?
3. 비즈니스 로직에서 발생할 수 있는 에러 코드를 정의하고 체계적으로 관리할 수 있는가?
4. 글로벌 에러 핸들러(Spring RestControllerAdvice 또는 NestJS ExceptionFilter)를 구현하고 예외 처리를 할 수 있는가?
5. 시스템에서 공통 기능을 처리하기 위해 Filter나 Interceptor를 적절히 활용할 수 있는가?
6. 통합된 기능에 대해 동시성 테스트를 포함한 통합 테스트를 작성하고 검증할 수 있는가?

# Chap3. 대용량 트래픽 & 데이터 처리
1. 시나리오 내에서 발생 가능한 동시성 이슈를 얼마나 구체적으로 파악하고 정의했는가?
2. 비즈니스 로직에 가장 적합한 DB Lock 방식을 선택하고 구현했는가?
3. 성능 개선을 위해 오래 걸리는 쿼리에서 캐싱 필요성을 정확히 파악하고 분석했는가?
4. Caching을 통해 부하를 최소화할 수 있는 비즈니스 로직을 정확히 파악하고 적용했는가?
5. 성능 최적화를 위한 적절한 인덱스 설계 및 실행과 쿼리를 분석할 수 있는가?
6. 서비스 기능에 따른 트랜잭션 범위와 분리를 이해하고, 설계 및 구현할 수 있는가?
7. Kafka를 활용하여 어플리케이션에 연동하며 카프카의 주요 개념(컨슈머, 브로커,  프로듀서 등)에 대해 이해하고 있는가?
 8. 어플리케이션 내에서 카프카를 통해 비즈니스 로직이 비동기로 수행될 때, 결과적 일관성을 보장하기 위한 Transactional Outbox Pattern을 이해하고 구현할 수 있는가?

 # Chap4. 장애 대응
 1. Latency, Disk, API 통신 지표의 변화를 감지하고 문제를 설명할 수 있는가?
2. 중앙화된 로거를 설정하고 로그에서 문제를 추적할 수 있는가?
3. Slack이나 Datadog과 같은 모니터링 툴을 이용하여 장애대응 파이프라인을 세팅하고, 발생한 문제를 설명할 수 있는가?
4. 애플리케이션 부하 테스트를 설계하고, TPS 및 응답시간을 분석할 수 있는가?
5. 적절한 부하 테스트 도구를 선택하고, 테스트를 실행 및 해석할 수 있는가?
6. 예상 병목지점을 고려한 테스트 시나리오를 작성하고 실행할 수 있는가?
7. 장애 유형별 원인을 분석하고 복구 방안을 제시할 수 있는가?
8. 장애 발생 시 대응 프로세스를 실행하고, 회고를 문서화할 수 있는가?
9. 애플리케이션의 SPOF를 식별하고 해결 방안을 제안할 수 있는가?

